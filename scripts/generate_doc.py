import os
import ast
import sys
from pathlib import Path
from typing import List, Optional, Any

class DocGenerator:
    """
    A simple documentation generator that parses Python source files using AST
    and generates a Markdown API reference.
    """
    def __init__(self, source_dir: Path, output_file: Path):
        self.source_dir = source_dir
        self.output_file = output_file
        self.content = []

    def generate(self):
        """Generates the documentation."""
        self.content.append("# Project API Documentation")
        self.content.append("\n> This documentation is auto-generated by `scripts/generate_doc.py`.")
        self.content.append("> It provides a reference for the project's modules, classes, and functions to assist LLMs in understanding the codebase.\n")
        
        self.content.append("## Project Structure")
        self.content.append("```")
        self._generate_tree(self.source_dir, "")
        self.content.append("```\n")

        self.content.append("## API Reference")

        # Walk through all python files
        for root, dirs, files in os.walk(self.source_dir):
            dirs.sort()
            files.sort()
            for file in files:
                if file.endswith(".py") and not file.startswith("__"):
                    file_path = Path(root) / file
                    self._process_file(file_path)
        
        # Ensure output directory exists
        self.output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(self.output_file, "w", encoding="utf-8") as f:
            f.write("\n".join(self.content))
        
        print(f"Documentation generated at: {self.output_file}")

    def _generate_tree(self, dir_path: Path, prefix: str):
        """Generates a directory tree structure."""
        items = sorted([i for i in os.listdir(dir_path) if not i.startswith(".") and not i.startswith("__")])
        for i, item in enumerate(items):
            is_last = i == len(items) - 1
            connector = "└── " if is_last else "├── "
            self.content.append(f"{prefix}{connector}{item}")
            
            item_path = dir_path / item
            if item_path.is_dir():
                new_prefix = prefix + ("    " if is_last else "│   ")
                self._generate_tree(item_path, new_prefix)

    def _process_file(self, file_path: Path):
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                source = f.read()
                tree = ast.parse(source)
        except Exception as e:
            print(f"Error parsing {file_path}: {e}")
            return

        rel_path = file_path.relative_to(self.source_dir.parent)
        module_name = str(rel_path).replace(os.sep, ".")[:-3] # remove .py
        
        self.content.append(f"\n---\n")
        self.content.append(f"### Module: `{module_name}`")
        
        docstring = ast.get_docstring(tree)
        if docstring:
            self.content.append(f"\n{docstring}\n")
            
        for node in tree.body:
            if isinstance(node, ast.ClassDef):
                self._process_class(node)
            elif isinstance(node, ast.FunctionDef):
                if not node.name.startswith("_"):
                    self._process_function(node, level=4)

    def _process_class(self, node: ast.ClassDef):
        bases = [self._get_name(base) for base in node.bases]
        base_str = f"({', '.join(bases)})" if bases else ""
        self.content.append(f"\n#### Class `{node.name}{base_str}`")
        
        docstring = ast.get_docstring(node)
        if docstring:
            self.content.append(f"\n{docstring}\n")
            
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                if not item.name.startswith("_") or item.name == "__init__":
                    self._process_function(item, is_method=True)

    def _process_function(self, node: ast.FunctionDef, is_method=False, level=4):
        args = self._format_args(node.args)
        returns = self._get_annotation(node.returns)
        return_str = f" -> {returns}" if returns else ""
        
        prefix = "- " if is_method else f"{'#' * level} Function "
        name_fmt = f"`{node.name}({args}){return_str}`"
        
        self.content.append(f"\n{prefix}{name_fmt}")
        
        docstring = ast.get_docstring(node)
        if docstring:
            # Indent docstring for methods to make it look cleaner in lists
            indent = "  " if is_method else ""
            # Clean up docstring indentation
            cleaned_doc = "\n".join([f"{indent}{line}" for line in docstring.splitlines()])
            self.content.append(f"\n{cleaned_doc}")

    def _format_args(self, args: ast.arguments) -> str:
        arg_list = []
        
        # Handle positional args
        defaults_start = len(args.args) - len(args.defaults)
        for i, arg in enumerate(args.args):
            arg_str = arg.arg
            if arg.annotation:
                arg_str += f": {self._get_annotation(arg.annotation)}"
            if i >= defaults_start:
                default = args.defaults[i - defaults_start]
                arg_str += f" = {self._get_value(default)}"
            arg_list.append(arg_str)
            
        # Handle *args
        if args.vararg:
            arg_str = f"*{args.vararg.arg}"
            if args.vararg.annotation:
                arg_str += f": {self._get_annotation(args.vararg.annotation)}"
            arg_list.append(arg_str)
            
        # Handle **kwargs
        if args.kwarg:
            arg_str = f"**{args.kwarg.arg}"
            if args.kwarg.annotation:
                arg_str += f": {self._get_annotation(args.kwarg.annotation)}"
            arg_list.append(arg_str)
            
        return ", ".join(arg_list)

    def _get_annotation(self, node) -> str:
        if node is None:
            return ""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return f"{self._get_annotation(node.value)}.{node.attr}"
        elif isinstance(node, ast.Subscript):
            value = self._get_annotation(node.value)
            slice_val = self._get_annotation(node.slice)
            return f"{value}[{slice_val}]"
        elif isinstance(node, ast.Tuple):
            return ", ".join([self._get_annotation(e) for e in node.elts])
        elif isinstance(node, ast.List):
            return f"[{', '.join([self._get_annotation(e) for e in node.elts])}]"
        elif isinstance(node, ast.Constant):
            return str(node.value)
        elif isinstance(node, ast.BinOp): # For Union types like int | str
             return f"{self._get_annotation(node.left)} | {self._get_annotation(node.right)}"
        return "Any"

    def _get_name(self, node) -> str:
        return self._get_annotation(node)

    def _get_value(self, node) -> str:
        if isinstance(node, ast.Constant):
            if isinstance(node.value, str):
                return f"'{node.value}'"
            return str(node.value)
        elif isinstance(node, ast.List):
            return "[]"
        elif isinstance(node, ast.Dict):
            return "{}"
        return "..."

if __name__ == "__main__":
    # Determine paths
    script_dir = Path(__file__).resolve().parent
    base_dir = script_dir.parent
    app_dir = base_dir / "app"
    doc_file = base_dir / "DOC.md"
    
    if not app_dir.exists():
        print(f"Error: App directory not found at {app_dir}")
        sys.exit(1)
        
    print(f"Scanning {app_dir}...")
    generator = DocGenerator(app_dir, doc_file)
    generator.generate()
